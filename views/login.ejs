<form action="/login" method="POST" id="loginForm">
    <input type="email" name="email" placeholder="Email" required />
    <input type="password" name="password" placeholder="Пароль" required />
    <button type="submit" class="btn-login" id="btnLogin">Войти</button>
  </form>

  <p class="register-block">Нет аккаунта? <a href="/register">Зарегистрироваться</a></p>

  <div class="success-text" id="successText">Начало к твоему успеху</div>

  <!-- SVG overlay: path, diode and circle -->
  <svg class="svg-overlay" id="svgOverlay" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none">
    <defs>
      <marker id="arrowMarker" markerWidth="12" markerHeight="12" refX="6" refY="6" orient="auto">
        <path d="M2,2 L10,6 L2,10 Z" fill="#00e0ff" />
      </marker>
    </defs>

    <!-- circle around success text: attributes will be set by JS -->
    <circle id="successCircle" cx="0" cy="0" r="0" stroke="rgba(0,224,255,0.16)" stroke-width="2.6" fill="rgba(0,224,255,0.03)"/>

    <!-- base muted path -->
    <path id="basePath" class="path-base" d="" />

    <!-- glow path on top -->
    <path id="glowPath" class="path-glow" d="" marker-end="url(#arrowMarker)" stroke-dasharray="6 8" stroke-dashoffset="0" />

    <!-- moving diode -->
    <circle id="diode" class="diode" cx="0" cy="0" r="6" style="visibility:hidden;" />
  </svg>
</div>

<script>
(function(){
  const panel = document.getElementById('panel');
  const successText = document.getElementById('successText');
  const registerBlock = document.querySelector('.register-block');
  const btnLogin = document.getElementById('btnLogin');

  const svg = document.getElementById('svgOverlay');
  const basePath = document.getElementById('basePath');
  const glowPath = document.getElementById('glowPath');
  const successCircle = document.getElementById('successCircle');
  const diode = document.getElementById('diode');

  function buildPath() {
    // compute bounding boxes in page coordinates
    const panelRect = panel.getBoundingClientRect();
    const successRect = successText.getBoundingClientRect();
    const registerRect = registerBlock.getBoundingClientRect();
    const btnRect = btnLogin.getBoundingClientRect();

    // compute coordinates relative to svg (svg positioned at left:0, right:0, bottom:-20px of panel)
    const svgRect = svg.getBoundingClientRect();
    const offsetX = svgRect.left;
    const offsetY = svgRect.top;

    // center points
    const startX = successRect.left + successRect.width/2 - offsetX;
    const startY = successRect.top + successRect.height/2 - offsetY;

    const endX = btnRect.left + btnRect.width/2 - offsetX;
    const endY = btnRect.top + btnRect.height/2 - offsetY;

    // circle radius to exactly surround text with padding
    const textWidth = successRect.width;
    const textHeight = successRect.height;
    const radius = Math.max(textWidth/2, textHeight/2) + 14;

    // set circle attributes
    successCircle.setAttribute('cx', startX);
    successCircle.setAttribute('cy', startY);
    successCircle.setAttribute('r', radius);

    // Determine a safe control Y to go above registerBlock
    // We'll route the curve such that it stays above the register block top by padding.
    const safeY = Math.min(successRect.top - offsetY - 20, registerRect.top - offsetY - 28);
    // safeY might be negative if small viewport; clamp it
    const clampSafeY = Math.max(safeY, Math.min(startY, endY) - 80);

    // Create smooth multi-segment cubic bezier path:
    // start at bottom of circle (slightly below center so the path visually flows from circle)
    const startOffsetY = startY + radius * 0.55;
    const sx = startX;
    const sy = startOffsetY;

    // We'll build 3 control points to create a wavy line that avoids registerBlock
    // ctrl1 near start, ctrl2 above register, ctrl3 near end
    const midX1 = sx + (endX - sx) * 0.25;
    const midX2 = sx + (endX - sx) * 0.55;
    const midX3 = sx + (endX - sx) * 0.80;

    const ctrl1x = midX1;
    const ctrl1y = clampSafeY - 10; // pull up a bitconst ctrl2x = midX2;
    const ctrl2y = clampSafeY - 22; // higher curve to clearly avoid

    const ctrl3x = midX3;
    const ctrl3y = clampSafeY - 6; // coming down a bit

    // final end slightly above the button center for arrow pointing to button top edge
    const finalEx = endX;
    const finalEy = endY - 8;

    // Build a smooth path with two cubic segments
    // Move to start point, then cubic to mid, then cubic to end.
    // Use control points to shape.
    const d = [
      `M ${sx} ${sy}`,
      `C ${ctrl1x} ${ctrl1y} ${ctrl2x} ${ctrl2y} ${ (sx + endX)/2 } ${ (clampSafeY + sy)/2 }`,
      `C ${ctrl3x} ${ctrl3y} ${finalEx} ${finalEy} ${finalEx} ${finalEy}`
    ].join(' ');

    basePath.setAttribute('d', d);
    glowPath.setAttribute('d', d);

    // place diode initially at start
    const pathLength = glowPath.getTotalLength();
    const startPoint = glowPath.getPointAtLength(0);
    diode.setAttribute('cx', startPoint.x);
    diode.setAttribute('cy', startPoint.y);
    diode.style.visibility = 'visible';

    return { pathLength, startX: sx, startY: sy, endX: finalEx, endY: finalEy };
  }

  // animate the diode along path; when reaches end -> pulse and animate button
  let animFrame;
  let startTime = null;
  let duration = 2200; // ms
  let pathLen = 0;
  function startAnimation() {
    cancelAnimationFrame(animFrame);
    startTime = null;
    const info = buildPath();
    pathLen = info.pathLength;

    // reset any previous classes
    diode.classList.remove('pulse');
    btnLogin.classList.remove('glow');

    function step(ts) {
      if (!startTime) startTime = ts;
      const elapsed = ts - startTime;
      const t = Math.min(1, elapsed / duration);
      // ease function (easeOutCubic)
      const eased = 1 - Math.pow(1 - t, 3);

      const dist = eased * pathLen;
      const pt = glowPath.getPointAtLength(dist);
      diode.setAttribute('cx', pt.x);
      diode.setAttribute('cy', pt.y);

      // optional: rotate diode a bit — not necessary here
      if (t < 1) {
        animFrame = requestAnimationFrame(step);
      } else {
        // arrived: pulse diode and glow button
        diode.classList.add('pulse');
        btnLogin.classList.add('glow');
        // after short time remove glow to allow repeat
        setTimeout(() => {
          btnLogin.classList.remove('glow');
        }, 1400);
      }
    }
    animFrame = requestAnimationFrame(step);
  }

  // Rebuild and start on load and when resizing (debounced)
  window.addEventListener('load', ()=> {
    // small delay to ensure layout settled
    setTimeout(startAnimation, 120);
  });

  let resizeTimeout;
  window.addEventListener('resize', ()=> {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(()=> {
      startAnimation();
    }, 160);
  });

  // Also restart animation on focus to draw attention
  window.addEventListener('focus', ()=> {
    startAnimation();
  });

  // If user clicks the login button, quickly animate diode to hit button
  btnLogin.addEventListener('mouseenter', ()=> {
    // optional: restart and speed to button to indicate interactivity
    duration = 1200;
    startAnimation();
    duration = 2200;
  });

})();
</script>
</body>
</html>